# Manejo de credenciales y secretos

La gestión de los secretos consiste en controlar las credenciales de TI, como las contraseñas, las claves de la interfaz de programación de aplicaciones (API) y los archivos de configuración. Las empresas de TI utilizan este proceso para mantener reservada y actualizada la información confidencial, mientras ponen los recursos controlados a disposición de las personas y los sistemas que los necesitan.

Es un concepto amplio. En un entorno empresarial, una buena gestión de los secretos generalmente implica almacenar los secretos en un solo lugar e integrar ese repositorio con herramientas de automatización de la TI. Para los equipos de desarrollo de software, la gestión de los secretos puede formar parte de los flujos de trabajo de DevSecOps.

El manejo incorrecto de credenciales y secretos es una de las **principales causas de incidentes de seguridad**.  

## ¿Qué entendemos por un secreto?

Un secreto es cualquier valor que, si cae en manos equivocadas, permite acceder a un sistema, escalar privilegios o suplantar identidades.  
Esto incluye desde contraseñas y connection strings hasta tokens, API keys, certificados o client secrets utilizados en flujos de autenticación.

Una buena regla mental es simple: si ese valor no debería aparecer en un Pull Request, en un log o en un mensaje de chat, entonces es un secreto.

## Separación entre código y secretos

Uno de los errores más comunes es mezclar lógica de negocio con valores sensibles.  
Cuando un secreto vive en el código, el repositorio deja de ser solo código y se convierte en un riesgo.

El código debe asumir que el secreto **existe**, pero no debe conocer su valor.  
La aplicación solo debería saber dónde leerlo en tiempo de ejecución.

Un ejemplo clásico de lo que no debe hacerse es definir directamente un API key o una cadena de conexión dentro del código. Aunque se haga “solo para probar”, ese valor termina viajando por commits, forks y backups.

El enfoque correcto es leer siempre estos valores desde el entorno, dejando que el sistema operativo, el pipeline o un vault se encarguen de inyectarlos en tiempo de ejecución.

## Entornos locales no son una excepción

Existe la falsa idea de que “es solo local” y por lo tanto se puede relajar la seguridad.  
En la práctica, los repositorios locales también se respaldan, se comparten y se sincronizan.

Para desarrollo local, los secretos deben vivir en archivos que:
- No se versionan
- Están explícitamente ignorados por Git
- Contienen valores específicos solo para ese entorno

Esto permite que cada desarrollador tenga su configuración sin comprometer la seguridad del proyecto ni del repositorio.

## Secretos en CI/CD y pipelines

En DevSecOps, el pipeline se convierte en el intermediario entre el código y los secretos.

Los valores sensibles deben almacenarse en mecanismos diseñados para eso, como variables seguras del pipeline o vaults dedicados.  
El pipeline se encarga de inyectar los secretos cuando se ejecuta un build o un deploy, sin exponerlos al desarrollador ni dejarlos registrados en logs.

Desde el punto de vista del código, no hay diferencia entre correr local o en producción: el secreto simplemente está disponible en el entorno cuando la aplicación arranca.

Esto permite rotar secretos, cambiar configuraciones o revocar accesos sin necesidad de modificar una sola línea de código.

## Principio de menor privilegio

No todos los secretos deberían hacer lo mismo ni tener el mismo alcance.  
Un token usado en QA no debería poder acceder a recursos de producción, y un API key de lectura no debería permitir operaciones destructivas.

Diseñar secretos con permisos mínimos reduce el impacto de una posible filtración.  
En DevSecOps, se asume que los errores pueden ocurrir, por lo que el sistema debe limitar el daño que pueden causar.


## Rotación y ciclo de vida de secretos

Un secreto no es algo permanente.  
Debe poder rotarse de forma periódica y, sobre todo, rápidamente cuando existe sospecha de compromiso.

Si rotar un secreto implica cambios manuales en el código, el diseño es incorrecto.  
La rotación debe ser una operación de configuración, no de desarrollo.

Este enfoque permite reaccionar rápido ante incidentes sin detener el flujo de trabajo ni bloquear releases.

## Logs y manejo de errores

Los logs son una herramienta fundamental para la observabilidad, pero también pueden convertirse en un vector de fuga de información.

Un error común es imprimir valores sensibles ***“solo para debug”***.  
Ese debug termina en archivos de log, sistemas de monitoreo o herramientas externas.

La regla es clara: los logs pueden indicar que un secreto fue cargado o utilizado, pero nunca mostrar su valor.  
El mensaje debe ayudar a diagnosticar el problema sin exponer información crítica.


## Pruebas y secretos

Las pruebas automáticas no deben depender de secretos reales.  
Utilizar credenciales de producción en tests, incluso de forma indirecta, crea riesgos innecesarios.

Las pruebas deben usar valores falsos, servicios mockeados o recursos temporales diseñados específicamente para testing.  
Esto permite que las pruebas sean reproducibles, seguras y ejecutables en cualquier entorno.

## El error más común: secretos en el código

Uno de los fallos más frecuentes es dejar secretos hardcodeados en archivos como:

- appsettings.json
- .env versionados
- Variables dentro del código (const string password = "1234")
- Archivos YAML de pipelines
- Scripts de despliegue

Aunque el repositorio sea privado, esto sigue siendo un riesgo:
- Cualquier desarrollador con acceso puede verlos
- Pueden filtrarse en logs o errores
- Un fork o backup accidental los expone
- Rotarlos después es costoso y propenso a errores

## Separación clara entre código y secretos

Una buena práctica fundamental es que el código solo conozca el nombre del secreto, nunca su valor.

Por ejemplo:

- El código espera una variable llamada DB_CONNECTION_STRING
- El valor real se inyecta desde el entorno (pipeline, runtime, vault)

Esto permite:

- Cambiar secretos sin recompilar
- Tener valores distintos por entorno (dev, qa, prod)
- Rotar credenciales sin tocar el código
- Auditar accesos y cambios

## Manejo de secretos en pipelines (CI/CD)

En pipelines, los secretos deben manejarse como variables seguras, nunca como texto plano.

En Azure DevOps, por ejemplo:

- Se definen variables marcadas como secret
- Se almacenan en Variable Groups o Key Vault
- Se inyectan en runtime
- No se muestran en logs (se enmascaran automáticamente)

Un pipeline bien configurado:

- No imprime secretos
- No los guarda en artefactos
- No los expone en errores
- Limita qué pipeline puede acceder a qué secreto
- Esto es DevSecOps aplicado: seguridad integrada al flujo de entrega.

## Uso de gestores de secretos

Para entornos productivos, lo ideal es usar un Secret Manager dedicado, como:

- Azure Key Vault
- AWS Secrets Manager
- HashiCorp Vault
- Secret Manager GCP

Estos servicios permiten:

- Control de acceso por rol
- Auditoría de lecturas y cambios
- Rotación automática
- Versionado de secretos
- Integración directa con pipelines y aplicaciones
- La aplicación nunca guarda el secreto, solo lo solicita cuando lo necesita.


## Buenas prácticas

Podríamos definir una serie de buenas prácticas bastante sencillas para eliminar los errores y vulnerabilidades comunes en este aspecto: 

- Separar completamente código y secretos
- Usar variables de entorno o gestores de secretos
- Limitar el acceso a secretos por rol y entorno
- Rotar credenciales de forma periódica
- Auditar accesos y cambios
- Enmascarar secretos en logs
- Usar herramientas de análisis como Checkmarx
- Tratar los pipelines como superficie de ataque
- Evitar la reutilización de secretos entre diferentes entornos
- Evitar imprimir variables sencibles en logs