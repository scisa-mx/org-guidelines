# Validaciones y sanitización de datos

La validación y sanitización de datos es uno de los pilares más básicos de la seguridad en software. Muchos incidentes de seguridad no ocurren por ataques sofisticados, sino porque la aplicación confía demasiado en los datos que recibe.

Desde una perspectiva **DevSecOps**, validar y sanitizar no es solo responsabilidad del backend o del frontend: es una práctica transversal que debe estar presente en el diseño, el código, las pruebas y los pipelines.

## El problema de confiar en el input

Todo dato que entra a un sistema debe considerarse no confiable, sin importar su origen:

- Requests HTTP
- Formularios web
- Payloads JSON
- Headers
- Variables de entorno
- Mensajes de colas
- Archivos subidos
- Datos provenientes de otros servicios internos

Un error común es asumir que:

- “El frontend ya valida”
- “El servicio es interno”

En seguridad, esas suposiciones casi siempre terminan mal. Las validaciones como minímo siempre se tienen que hacer por parte del backend, y desde un inicio tener bien establecido como y cuales son estos inputs.

## Validación vs sanitización
***Validar*** significa verificar que un dato cumple con las reglas esperadas:

- Tipo correcto
- Rango permitido
- Formato válido
- Longitud aceptable
- Estados permitidos

***Sanitizar*** significa limpiar o transformar el dato para eliminar contenido peligroso:

- Escapar caracteres especiales
- Eliminar scripts
- Normalizar strings
- Quitar contenido no permitido

Ambos conceptos son utilizados siempre en proyectos grandes o con información sencible, pero normalmente se validan los datos primero y la etapa de sanitización viene posteriormente.

## Ejemplo: validación en una API

Supongamos un endpoint que recibe un objeto para crear un usuario.

Validaciones esperadas:

- El email tiene formato válido
- La contraseña cumple reglas mínimas
- El rol pertenece a un conjunto permitido
- Los campos obligatorios existen

Si el sistema no valida:

- Se pueden enviar valores inesperados
- Se pueden forzar estados inválidos
- Se pueden provocar errores o bypass de lógica

Este tipo de validaciones no solo previenen ataques, también evitan bugs funcionales.

Un ejemplo con codigo sería:

```csharp
// Nunca confiar en strings libres para permisos.
// Esto previene:
// - Escalamiento de privilegios
// - Roles “inventados” (SuperAdmin, Root, etc.)

public static class UserRoles
{
    public const string Admin = "Admin";
    public const string User = "User";
    public const string Support = "Support";

    public static readonly HashSet<string> Allowed =
        new(StringComparer.OrdinalIgnoreCase)
        {
            Admin,
            User,
            Support
        };
}

[ApiController]
[Route("api/users")]
public class UsersController : ControllerBase
{
    [HttpPost]
    public IActionResult CreateUser([FromBody] CreateUserRequest request)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        if (!UserRoles.Allowed.Contains(request.Role))
        {
            return BadRequest($"Role '{request.Role}' is not allowed.");
        }

        // Aquí ya sabemos que:
        // - El input es válido
        // - No hay estados ilegales
        // - No hay bypass de lógica

        return Ok();
    }
}

```

### Ejemplo de que NO se debe de hacer:

```csharp
public IActionResult CreateUser(dynamic request)
{
    var sql = $"INSERT INTO Users VALUES ('{request.Email}', '{request.Password}', '{request.Role}')";
    // SQL Injection waiting to happen
}
```

Problemas graves:

- No hay validación
- No hay sanitización
- Riesgo directo de SQL Injection
- Bypass total de reglas


## Sanitización y ataques comunes

La falta de sanitización abre la puerta a ataques conocidos, como:

**SQL Injection**
Cuando inputs se concatenan directamente en queries sin validación ni parametrización.

**Cross-Site Scripting (XSS)**
Cuando contenido no sanitizado se renderiza en HTML o vistas.

**Command Injection**
Cuando datos del usuario se usan en comandos del sistema.

**Header Injection**
Cuando inputs llegan sin filtrar a headers HTTP.

Estos problemas siguen apareciendo hoy no por desconocimiento, sino por malas prácticas repetidas.

## Validaciones en múltiples capas

Un enfoque DevSecOps recomienda validar en más de una capa:

- **Frontend**: para mejorar UX y reducir errores
- **Backend**: como validación definitiva y obligatoria
- **Dominio**: reglas de negocio
- **Base de datos**: constraints y tipos
- **Integraciones**: validación de contratos

El backend nunca debe confiar en que otra capa ya validó.

## Checkmarx y validaciones

Internamente utilizamos Checkmarx para detectar:

- Falta de validación de inputs
- Uso inseguro de parámetros
- Posibles inyecciones
- Manipulación de datos sin sanitización

Checkmarx analiza el flujo de datos (data flow) y detecta si información externa llega a puntos críticos sin controles adecuados, ayudando a encontrar problemas antes de producción.

