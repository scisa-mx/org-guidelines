# Versionamiento semantico o propio

El versionamiento semántico es el estándar principal en cualquier organización o proyecto grande de software. 
No es opcional ni decorativo: es parte del contrato técnico entre equipos.

## ¿Qué es el versionamiento sémantico?  

Es una de las convenciones de nomenclatura de versiones más populares para entender las versiones de un software, que proporciona una manera semántica y consistente etiquetas para rastrear las versiones de un proyecto de software.

Esta nomenclatura nos permite conocer el estado de una aplicación de manera simple y la podemos encontrar como una serie de número dividido en tres grupos separados por un punto. Cada grupo se conoce como mayor, menor y parche respectivamente (major, minor y patch en inglés o también como x, y, z), por ejemplo: 1.0.1, 2.1.0, 14.2.9, etc…

El formato oficial es:

```
MAJOR.MINOR.PATCH
```

Donde:

- **MAJOR** → Cambios incompatibles
- **MINOR** → Funcionalidad nueva compatible
- **PATCH** → Correcciones compatibles

## Reglas de incremento
PATCH – Correcciones compatibles
Incrementar PATCH cuando:

- Se corrige un bug
- Se mejora rendimiento sin cambiar comportamiento
- Se ajusta lógica interna sin romper contratos

Ejemplo:

```
1.4.2 → 1.4.3
```

MINOR – Funcionalidad nueva compatible

Incrementar MINOR cuando:

- Se agregan endpoints nuevos
- Se agregan propiedades opcionales
- Se extiende comportamiento existente sin romperlo

Ejemplo
```
1.4.3 → 1.5.0
```


MAJOR – Cambios incompatibles

Incrementar MAJOR cuando:

- Se rompe compatibilidad
- Se eliminan endpoints
- Cambia comportamiento esperado
- Cambia el contrato público

Ejemplo: 

```
1.9.0 → 2.0.0
```

### Ejemplo práctico (.NET API)

```csharp
// Antes
Task<OrderDto> GetOrder(Guid id);

// Después
Task<OrderSummaryDto> GetOrder(Guid id);
```

***Cambio incompatible*** → Requiere incremento MAJOR

## Conexión con Git Flow

El versionamiento no ocurre aislado, está directamente ligado al flujo de ramas.

| Rama      | Propósito             | Versionamiento         |
| --------- | --------------------- | ---------------------- |
| main      | Producción            | Versiones finales      |
| develop   | Integración           | Próxima versión        |
| release/* | Estabilización        | Congelación de versión |
| hotfix/*  | Correcciones urgentes | PATCH                  |


---

**Feature branches**

Nunca cambian versión
Contribuyen a la siguiente MINOR o MAJOR
El impacto se define en el PR

---

Release branches

Ejemplo:

```bash
release/2.1.0
```
En esta rama la versión ya está definida por lo que solo se aceptan:

- Bug fixes
- Ajustes menores
- No se agregan features

---

**Hotfix branches**

Ejemplo:

```bash
hotfix/2.1.1
```

Reglas:
- Solo PATCH
- Se crea desde main
- Se mergea a main y develop


Decidir la versión en el PR

La versión se decide antes del merge, no después.

Todo PR debe indicar:

Tipo de cambio

Impacto (PATCH / MINOR / MAJOR)

Justificación técnica

Ejemplo en descripción de PR
Impacto de versión: MINOR

Se agregan endpoints nuevos sin romper compatibilidad.


Un PR sin impacto de versión no está completo.

## Relación con commits

Los commits ayudan a inferir la versión, pero no la sustituyen.

Ejemplo:

fix: → candidato a PATCH

feat: → candidato a MINOR

Breaking change documentado → MAJOR

## Versionado y releases

Cada versión publicada debe incluir:

- Tag en Git (v2.1.0)
- Changelog
- Fecha y responsable