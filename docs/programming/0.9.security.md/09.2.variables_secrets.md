# Manejo de credenciales y secretos

La gestión de secretos consiste en controlar credenciales sensibles como contraseñas, API keys, tokens, certificados y connection strings.  
El manejo incorrecto de estos elementos es una de las principales causas de incidentes de seguridad.

En un enfoque DevSecOps, los secretos no se gestionan manualmente ni se almacenan en el código: se integran de forma segura en el flujo de desarrollo y despliegue.

## ¿Qué es un secreto?

Un secreto es cualquier valor que, si se expone, permite acceder a sistemas, escalar privilegios o suplantar identidades.

Regla simple:  
Si no debería aparecer en un Pull Request, en un log o en un mensaje de chat, entonces es un secreto.

---

## Separación entre código y secretos

El código nunca debe contener valores sensibles hardcodeados.

Incorrecto:
- Definir API keys directamente en el código
- Versionar archivos `.env`
- Incluir credenciales en `appsettings.json`
- Colocar secretos en YAML de pipelines o scripts

Correcto:
- El código solo conoce el nombre del secreto
- El valor se inyecta en tiempo de ejecución
- Se usan variables de entorno o gestores de secretos

Esto permite:
- Cambiar secretos sin modificar código
- Diferenciar entornos (dev, qa, prod)
- Rotar credenciales fácilmente
- Reducir riesgos ante filtraciones

---

## Entornos locales

“Es solo local” no es una excusa.

Para desarrollo:
- Usar archivos no versionados
- Ignorar configuraciones sensibles en Git
- Mantener secretos específicos por entorno

---

## Secretos en CI/CD

En DevSecOps, los pipelines gestionan la inyección de secretos.

Buenas prácticas:
- Usar variables seguras del pipeline
- No exponer secretos en logs
- No almacenarlos en artefactos
- Limitar acceso por entorno

La aplicación debe comportarse igual en local, QA o producción: el secreto simplemente existe en el entorno al arrancar.

---

## Uso de gestores de secretos

En entornos productivos, se recomienda usar herramientas especializadas como:

- Azure Key Vault
- AWS Secrets Manager
- HashiCorp Vault
- Google Secret Manager

Estos permiten:
- Control de acceso por rol
- Auditoría de uso
- Rotación automática
- Versionado
- Integración con pipelines

La aplicación nunca almacena el secreto, solo lo solicita cuando lo necesita.

---

## Principio de menor privilegio

Cada secreto debe tener permisos mínimos necesarios.

Ejemplos:
- Token de lectura no debe permitir escritura
- QA no debe acceder a producción
- No reutilizar el mismo secreto en todos los entornos

Si ocurre una filtración, el impacto será limitado.

---

## Rotación y ciclo de vida

Los secretos no deben ser permanentes.

- Deben poder rotarse periódicamente
- Deben revocarse rápidamente ante incidentes
- La rotación no debe requerir cambios de código

Si cambiar un secreto implica modificar el repositorio, el diseño es incorrecto.

---

## Logs y errores

Nunca imprimir secretos en logs, ni siquiera para debug.

Los logs pueden indicar que el secreto fue cargado, pero jamás mostrar su valor.

---

## Pruebas y secretos

Las pruebas automáticas no deben usar credenciales reales.

- Usar mocks
- Usar valores ficticios
- Evitar acceso a recursos productivos

Esto mantiene los tests seguros y reproducibles.

---

## Buenas prácticas

- Separar código y secretos
- Usar variables de entorno o vaults
- No versionar credenciales
- Limitar acceso por rol y entorno
- Rotar periódicamente
- Enmascarar secretos en logs
- No reutilizar secretos entre entornos
- Tratar pipelines como superficie de ataque
- Utilizar herramientas de análisis como Checkmarx para detectar secretos hardcodeados

---

## Conclusión

El manejo correcto de credenciales no es solo una práctica técnica, sino una disciplina de seguridad.

Un sistema seguro no asume que los secretos están protegidos:  
diseña el flujo para que nunca estén expuestos.
