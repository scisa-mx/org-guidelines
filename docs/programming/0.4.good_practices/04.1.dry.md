# DRY — Don't Repeat Yourself

DRY significa Don't Repeat Yourself — No te repitas.
Es una regla que se basa en un concepto sencilo: "evita duplicar lógica, datos o conocimiento en más de un lugar". Si necesitas cambiar algo, debería bastar con modificarlo en un solo sitio. Esto reduce errores, facilita mantenimiento y acelera cambios.

## ¿Por qué importa?

- Si copias y pegas código en varias partes y luego hay que cambiar la lógica, es fácil olvidar alguno de los lugares y crear bugs.
- El código se vuelve más largo y difícil de leer.
- Facilita escribir pruebas (tests): pruebas únicas para una pieza reutilizable en lugar de pruebas duplicadas.
- Mejora consistencia: la misma entrada produce la misma salida en toda la app.


## ¿Cuándo NO aplicar DRY?

- Cuando dos piezas parecen iguales pero representan conceptos distintos (evita abstraer prematuramente).
- Cuando forzar una abstracción complica más que ayuda (abstracción demasiado genérica).
- Cuando el costo de cambiar muchas dependencias supera el beneficio (p. ej. código legado crítico, en este caso es mejor analizar para poder elaborar un refactor completo y adecuado).

## Ejemplos prácticos en .NET (C#)

### Ejemplo 1 — Violación de DRY (duplicación de validación)

```csharp
// Controller A
public IActionResult CreateUser(CreateUserModel model)
{
    if (string.IsNullOrWhiteSpace(model.Email) || !model.Email.Contains("@"))
        return BadRequest("Email inválido");

    // lógica de crear usuario...
}

// Controller B
public IActionResult RegisterClient(RegisterClientModel model)
{
    if (string.IsNullOrWhiteSpace(model.Email) || !model.Email.Contains("@"))
        return BadRequest("Email inválido");

    // lógica de registrar cliente...
}
```

__Problema: la validación del email está copiada. Si la regla cambia, hay que actualizar dos lugares.__

### Refactor: extraer validación a un servicio/shared helper

```csharp
public interface IValidationService
{
    bool IsValidEmail(string email);
}

public class ValidationService : IValidationService
{
    public bool IsValidEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email)) return false;
        try {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        } catch {
            return false;
        }
    }
}

// Uso en controllers (inyectar IValidationService)
public IActionResult CreateUser(CreateUserModel model)
{
    if (!_validationService.IsValidEmail(model.Email))
        return BadRequest("Email inválido");
    // ...
}
```

__Beneficio: regla central, más fácil de probar, cambiar y reutilizar.__

### Ejemplo 2 — Violación de DRY (lógica de mapeo repetida)

```csharp
// Repetido en varios lugares
var dto = new UserDto {
    Id = user.Id,
    Username = user.Username,
    CreatedAt = user.CreatedAt.ToString("yyyy-MM-dd")
};
```

Refactor con extensión o mapper:

```csharp
// Extension method
public static class MappingExtensions
{
    public static UserDto ToDto(this User user) => new UserDto {
        Id = user.Id,
        Username = user.Username,
        CreatedAt = user.CreatedAt.ToString("yyyy-MM-dd")
    };
}

// Uso
var dto = user.ToDto();
```
O usar AutoMapper para proyectos grandes. Resultado: mapeo centralizado, menos errores.

### Ejemplo 3 — Constantes y magic strings

Evita repetir cadenas o "números mágicos/magic numbers".

```csharp
// Malo: repetido en varios lados
if (role == "Admin") { ... }

// Mejor
public static class Roles
{
    public const string Admin = "Admin";
}
// Uso
if (role == Roles.Admin) { ... }
```

## Buenas prácticas al aplicar DRY

- Empieza por duplicaciones obvias: validaciones, mapeos, consultas SQL, formatos de fecha, manejo de errores, log.
- Escribe pruebas unitarias para la abstracción nueva.
- Prefiere pequeñas abstracciones y comprensibles (no "mega-clases" genéricas).
- Documenta la intención: por qué existe la abstracción y qué contratos (inputs/outputs) tiene.
- Revisa dependencias para evitar over-abstraction (acoplamiento fuerte).

