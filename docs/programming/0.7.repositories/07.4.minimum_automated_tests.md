# Pruebas automáticas mínimas requeridas

Las pruebas automáticas no son un lujo ni una fase opcional del desarrollo.  
Son una **red de seguridad** que permite cambiar el sistema con confianza, escalar equipos y reducir regresiones en producción.

Estas reglas definen el **mínimo aceptable** de pruebas para cualquier proyecto dentro de la organización.

---

## 1. Principio base: código sin pruebas es código no confiable

Toda pieza de código que:
- Se despliega
- Se mantiene
- Se reutiliza

Debe poder **demostrar que funciona** de forma automática.

Principio clave:
> Si no se puede probar automáticamente, no se puede escalar con seguridad.

---

## 2. Tipos de pruebas y alcance mínimo esperado

No todas las pruebas tienen el mismo objetivo. El enfoque es **equilibrio**, no cobertura artificial.

---

## 3. Pruebas unitarias

### 3.1 Qué deben cubrir

Las pruebas unitarias deben validar:
- Lógica de negocio
- Reglas
- Casos borde
- Validaciones

Ejemplos:
- Cálculo de valores
- Transformaciones de datos
- Validaciones de estados
- Comportamiento esperado ante inputs inválidos

---

### 3.2 Qué no deben cubrir

Las pruebas unitarias **no deben**:
- Acceder a base de datos real
- Llamar servicios externos
- Depender de infraestructura

Todo lo externo debe ser:
- Mockeado
- Stubbeado
- Simulado

---

### 3.3 Reglas mínimas

- Toda lógica de negocio nueva debe tener pruebas unitarias
- Un bug corregido debe incluir una prueba que lo cubra
- Las pruebas deben ser:
  - Rápidas
  - Determinísticas
  - Aisladas

#### Ejemplos concretos

**Ejemplo 1: Regla de negocio**

Supongamos una regla que no permite procesar órdenes con monto negativo.

```csharp
public decimal CalculateTotal(decimal amount)
{
    if (amount < 0)
        throw new ArgumentException("Amount cannot be negative");

    return amount * 1.16m;
}
```

Pruebas unitarias esperadas:
- Retorna el total con IVA cuando el monto es válido
- Lanza excepción cuando el monto es negativo
- Maneja correctamente el valor cero


**Ejemplo 2: Casos de Edge**
```csharp
public bool IsPasswordValid(string password)
{
    return !string.IsNullOrEmpty(password) && password.Length >= 8;
}
```
Pruebas unitarias:

- Password con 8 caracteres es válido
- Password con menos de 8 caracteres es inválido
- Password nulo o vacío es inválido

Lo que buscamos es: 
***Si una regla puede romperse con un input inesperado, debe tener una prueba que lo demuestre.***

---

## 4. Pruebas de integración

### 4.1 Cuándo son obligatorias

Las pruebas de integración son obligatorias cuando:
- Se interactúa con base de datos
- Se consume un servicio externo
- Se integran múltiples módulos

Ejemplos:
- Repositorios
- APIs
- Mensajería
- Persistencia

---

### 4.2 Enfoque recomendado

- Usar entornos controlados
- Bases de datos temporales o en memoria
- Configuración reproducible


#### Ejemplos concretos

**Ejemplo 1: Repositorio con base de datos**
```csharp
public class UserRepository
{
    public Task<User> GetByIdAsync(Guid id);
}

```
Prueba de integración esperada:

- Inserta un usuario en una base de datos temporal
- Recupera el usuario por ID
- Valida que los datos persisten correctamente
- No se mockea la base de datos, se valida la integración real.

**Ejemplo 2: API REST**
```bash
POST /api/users
```

Prueba de integración:

- Se envía un request HTTP real
- Se valida código de respuesta (201)
- Se valida que el usuario fue persistido
- Se valida el contrato de respuesta

**Ejemplo 3: Mensajería**

Si el sistema publica un evento al crear una orden:
- La prueba valida que el evento se emite
- El mensaje contiene los datos correctos
- El consumidor puede procesarlo sin errores

---

## 5. Pruebas de contrato o API

Cuando el sistema expone interfaces:
- APIs REST
- GraphQL
- Mensajes
- Eventos

Debe existir al menos:
- Validación de contratos
- Validación de esquemas
- Validación de códigos de respuesta

Esto reduce:
- Rupturas entre equipos
- Cambios no compatibles
- Errores en clientes

---

## 6. Pruebas end-to-end (E2E)

### 6.1 Uso recomendado

Las pruebas E2E:
- No reemplazan pruebas unitarias
- No deben cubrir todos los flujos
- Deben enfocarse en flujos críticos

Ejemplos:
- Login
- Compra
- Flujo principal de negocio

---

### 6.2 Reglas

- Pocas, pero significativas
- Ejecutables en pipeline
- Estables y mantenibles

Principio:
> Muchas E2E frágiles son peor que pocas E2E confiables.

---

## 7. Reglas para Pull Requests

Todo Pull Request debe cumplir:
- No romper pruebas existentes
- Incluir pruebas para lógica nueva
- Incluir pruebas para correcciones de bugs

Un PR sin pruebas:
- Debe justificar explícitamente el motivo
- Puede ser rechazado

---

## 8. Integración con CI/CD

Las pruebas automáticas deben:
- Ejecutarse en cada Pull Request
- Bloquear merges si fallan
- Ejecutarse antes de cualquier release

El pipeline es el **árbitro**, no el desarrollador.

---

## 9. Cobertura de código

La cobertura:
- Es una métrica de apoyo
- No un objetivo en sí mismo

Reglas:
- No sacrificar calidad por porcentaje
- Priorizar cobertura en lógica crítica
- Evitar pruebas artificiales solo para subir métricas

---

## 10. Mantenimiento de pruebas

Las pruebas son código y deben:
- Mantenerse
- Refactorizarse
- Revisarse en PRs

Regla clara:
> Una prueba rota es deuda técnica.

---

## 11. Errores comunes a evitar

- Probar solo el camino feliz
- Pruebas dependientes entre sí
- Pruebas lentas en unit tests
- Tests que pasan solo en local
- Ignorar pruebas fallidas

