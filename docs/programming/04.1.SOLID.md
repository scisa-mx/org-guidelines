# SOLID

SOLID es un conjunto de 5 principios que ayudan a escribir código:
- más fácil de entender
- más fácil de mantener
- más fácil de extender
- menos propenso a errores

No son reglas estrictas, sino guías de diseño, si no que su objetivo es mejorar la calidad del código.

## ¿Qué significa SOLID?

- **S** — Single Responsibility Principle (SRP) — Principio de Responsabilidad Única
- **O** — Open/Closed Principle (OCP) — Principio de Abierto/Cerrado
- **L** — Liskov Substitution Principle (LSP) — Principio de Sustitución de Liskov
- **I** — Interface Segregation Principle (ISP) — Principio de Segregación de Interfaces
- **D** — Dependency Inversion Principle (DIP) — Principio de Inversión de Dependencias


## S — Single Responsibility Principle (SRP)
Una clase debe tener una sola responsabilidad y, por lo tanto, una sola razón para cambiar.

Esto significa que:

- Una clase no debe mezclar diferentes tipos de lógica.
- Si cambian las reglas de negocio, solo una clase debería verse afectada.
- Si una clase tiene muchas razones para cambiar, es señal de que está haciendo demasiado.

### Problema que resuelve
- Clases grandes que nadie quiere tocar
- Cambios pequeños que rompen cosas inesperadas
- Dificultad para escribir pruebas unitarias
- Código difícil de entender

### Ejemplo de violación de SRP

```csharp
public class InvoiceService
{
    public void CreateInvoice(Invoice invoice)
    {
        SaveInvoice(invoice);
        GeneratePdf(invoice);
        SendEmail(invoice);
        WriteLog(invoice);
    }
}
```

Esta clase cambia si:

- cambia la base de datos
- cambia el formato del PDF
- cambia el envío de correos
- cambia el sistema de logs

Por lo que tiene múltiples responsabilidades, dejamos muchas tareas a una sola clase lo que puede causar problemas a largo plazo al momento de mantener el código.

### Aplicando SRP

```csharp
public class InvoiceService
{
    // Dejamos una clase por cada responsabilidad, inyectándolas por constructor.
    private readonly IInvoiceRepository _repo;
    private readonly IPdfGenerator _pdf;
    private readonly IEmailService _email;
    private readonly ILogger _logger;

    public void CreateInvoice(Invoice invoice)
    {
        _repo.Save(invoice);
        _pdf.Generate(invoice);
        _email.Send(invoice);
        _logger.Log("Invoice created");
    }
}
```

Cada clase tiene una responsabilidad clara y aislada.

## O — Open / Closed Principle (OCP)

Las entidades de software deben estar abiertas para extenderse, pero cerradas para modificarse.

Esto quiere decir que:
- El código ya probado no debería modificarse constantemente.
- Nuevas reglas o comportamientos se agregan creando nuevas clases.
- Se reduce el riesgo de introducir errores en código estable.

### Problema que resuelve

- Condicionales grandes (if, switch)
- Cambios que rompen funcionalidades anteriores
- Código difícil de escalar

### Ejemplo de violación de OCP

```csharp
public decimal CalculateDiscount(string type, decimal amount)
{
    if (type == "Student") return amount * 0.9m;
    if (type == "Vip") return amount * 0.8m;
    return amount;
}
```
Cada nuevo descuento implica editar esta función, lo que puede romper descuentos existentes, o simplemente olvidarnos de actualizarla si en algun momento cualquier descuento cambia.

### Aplicando OCP

```csharp
public interface IDiscountRule
{
    decimal Apply(decimal amount);
}

public class StudentDiscount : IDiscountRule
{
    public decimal Apply(decimal amount) => amount * 0.9m;
}

public class VipDiscount : IDiscountRule
{
    public decimal Apply(decimal amount) => amount * 0.8m;
}

```

Extiendes comportamiento sin tocar código existente, solo agregando nuevas clases que implementen la interfaz.


## L — Liskov Substitution Principle (LSP)
Los objetos de una clase base deben poder ser reemplazados por objetos de sus clases derivadas sin alterar el comportamiento esperado del sistema.

En términos simples:

- Una clase hija no debe sorprender al código que la usa.
- No debe lanzar errores inesperados.
- No debe cambiar el significado de lo que promete la clase base.


### Problema que resuelve

- Herencias incorrectas
- Excepciones inesperadas
- Código defensivo innecesario

### Ejemplo de violación de LSP

```csharp
public class Account
{
    public virtual void Withdraw(decimal amount) { }
}

public class FixedDepositAccount : Account
{
    public override void Withdraw(decimal amount)
    {
        throw new NotSupportedException();
    }
}
```
La clase hija rompe el contrato.


### Aplicando LSP

```csharp
public interface IWithdrawable
{
    void Withdraw(decimal amount);
}

public class SavingsAccount : IWithdrawable { }

public class FixedDepositAccount
{
    // No permite retiro
}
```
Cada clase cumple su contrato sin romper expectativas.

## I — Interface Segregation Principle (ISP)

Los clientes no deben depender de interfaces que no usan. Este concepto tiene la noción de que “muchas interfaces cliente específicas son mejores que una interfaz de propósito general”.

Esto implica:

- Interfaces pequeñas y enfocadas.
- Evitar “interfaces gigantes”.
- Clases más simples de implementar y mantener.

### Problema típico que resuelve

- Métodos NotImplementedException
- Clases difíciles de entender
- Cambios que afectan muchas clases


## D — Dependency Inversion Principle (DIP)

Los módulos de alto nivel no deben depender de módulos de bajo nivel. Ambos deben depender de abstracciones. Las abstracciones no deben depender de los detalles. Los detalles deben depender de las abstracciones.


Esto significa:
- Evita crear dependencias con new
- Usa interfaces
- Permite cambiar implementaciones sin romper lógica

### Violacion de DIP

```csharp
public class PaymentService
{
    private readonly PaypalService _paypal = new PaypalService();
}
```

### Aplicando DIP

```csharp
public interface IPaymentService
{
    void Pay(decimal amount);
}

public class PaymentProcessor
{
    private readonly IPaymentService _service;

    public PaymentProcessor(IPaymentService service)
    {
        _service = service;
    }
}
```

