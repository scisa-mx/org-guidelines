# 4.5 Logs y observabilidad 

## ¿Por qué Logs y Observabilidad son críticos?
En ambientes modernos (microservicios, cloud, contenedores), los logs ya no son solo texto.

Un buen sistema de observabilidad permite:

- Detectar errores antes de que impacten al negocio
- Entender qué pasó, dónde y por qué
- Reducir MTTR (Mean Time To Recovery)
- Correlacionar eventos entre múltiples servicios
- Auditar y analizar comportamiento en producción


## Principios base (organizacionales)
Antes de hablar de código, estos son los principios que deben cumplirse siempre:

### Logs estructurados (NO texto plano)

Mala práctica:
```csharp
Log.Information("Error al guardar usuario");
```
Mejor implementación:
```csharp
Log.Information("Error al guardar usuario {@UserId}, body: {@Body}", userId, body);
```

Osease que: **Todo log debe ser machine-readable (JSON, propiedades, labels).**

### Logs ≠ Debugging

Los logs NO reemplazan el debugger o sesiones de debugging.

- Logs -> explican qué pasó
- Debugger -> explica por qué pasó

### Logs deben responder preguntas

- ¿Qué pasó?
- ¿Dónde pasó?
- ¿A quién afectó?
- ¿En qué entorno?
- ¿Está relacionado con otra operación?

Si alguno de estos puntos no puede ser respondido con los logs, el sistema de logging es insuficiente, debería de hacer una revisión para mejorarlo.

## Niveles de Log (uso correcto)

| Nivel         | Uso correcto                          |
| ------------- | ------------------------------------- |
| `Debug`       | Detalles técnicos, solo desarrollo    |
| `Information` | Flujo normal del sistema              |
| `Warning`     | Situaciones anómalas pero controladas |
| `Error`       | Fallos que afectan una operación      |
| `Fatal`       | El sistema no puede continuar         |

Siempre trata de evitar usar niveles más altos de los necesarios. Un `Error` no debe usarse para un `Warning`, y un `Debug` no debe usarse para un `Information`.

## Análisis del Configurador Actual (Serilog y Cloud run)

Actualmente el sistema de logging usa Serilog con sinks a consola y Stackdriver (Google Cloud Logging).

### Logger de arranque (Startup Logger)

```csharp
.WriteTo.File(environmentPathLog, rollingInterval: RollingInterval.Day)
```

Captura errores antes de que cargue la app completa
Ideal para diagnósticos de startup

### Configuración por entorno

```csharp
var environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT");
```

Esto permite:
Niveles distintos por entorno
Sinks distintos (File, Console, Loki)

### Enrichers (contexto automático)

```csharp
.Enrich.FromLogContext()
.Enrich.WithMachineName()
.Enrich.WithExceptionDetails()
.Enrich.WithProperty("Environment", environment)
```

Esto permite:

- Saber en qué máquina
- Qué entorno
- Stacktrace enriquecido
- Correlación entre logs

## Observabilidad: Correlación y Trazabilidad

```csharp
.Enrich.With<ActivityEnricher>()
```

Esto permite:

Correlacionar requests entre servicios

Integrarse con OpenTelemetry

Visualizar flujos completos en Grafana

Todo request debe tener un TraceId compartido

### Logs sin correlación = logs inútiles

Si no puedes responder:

“¿Este error a qué request pertenece?”

Entonces no hay observabilidad real.

## Logging en Cloud (Cloud Run / Kubernetes)

En algunas aplicaciones desplegadas en la nube, los logs se recogen automáticamente desde la salida estándar (stdout) y error (stderr).
Por eso es crucial que los logs estén estructurados y sean consistentes, para que las herramientas de monitoreo puedan interpretarlos correctamente.

En nuestro caso, al usar Google Cloud Run, los logs enviados a la consola se recogen automáticamente en Google Cloud Logging, donde pueden ser filtrados, analizados y visualizados. Pero es necesario una configuracuión adecuada para aprovechar esto. Es necesario tener la librería de Scisa.Common Logging instalada y configurada correctamente en cada proyecto.

```csharp
public static void ConfigureLogging(string serviceName = "", string uriLoki = "", bool cloudRunEnvironment = false) {
    if (cloudRunEnvironment)
    {
        loggerConfig.WriteTo.Console(...)
    }
}

```

Esto asegura que los logs se envíen correctamente a la plataforma de nube y se integren con sus herramientas de monitoreo y análisis.
En nuestro codigo de `startup.cs` debemos asegurarnos de llamar a este método con el parámetro `cloudRunEnvironment` establecido en `true` cuando estemos desplegando en Cloud Run.

```csharp
var cloudRunEnviroment = config.GetValue<bool>("AppSettings:CloudRunEnviroment", false);
```

y en nuestros proyectos debemos tener en el `appsettings.json` la siguiente configuración:

```json
{
  "AppSettings": {
    "BaseUrl": "<localhost>",
    "ProviderName": "<name>",
    "AppName": "<name>",
    "CloudRunEnviroment": true
  }
}
```
## Centralización de Logs (Grafana Loki)

```csharp
.WriteTo.GrafanaLoki(uriLoki,
    labels: new[]
    {
        new LokiLabel { Key = "service_name", Value = serviceName }
    });
```

Esto permite:

- Filtrar por servicio
- Dashboards centralizados
- Alertas basadas en logs

## Estructura recomendada de logs

Ejemplo ideal para estructura de log en JSON:
```json
{
  "timestamp": "2026-01-20T10:32:01Z",
  "level": "Error",
  "message": "Error al procesar orden",
  "orderId": 12345,
  "userId": "abc123",
  "traceId": "9f8a7c",
  "service": "orders-api",
  "environment": "Production"
}
```

## Conclusión

> Logging sin observabilidad es solo ruido.
> Observabilidad sin disciplina es caos.

El código compartido en SCISA establece una base sólida.
El reto no es técnico, es cultural y de consistencia.