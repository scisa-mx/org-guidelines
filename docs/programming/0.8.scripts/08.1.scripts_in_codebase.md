# ¿Cómo agregar scripts al codebase?
Agregar scripts a un codebase es algo común y necesario: automatizan tareas, aceleran flujos de trabajo y reducen errores humanos. Sin embargo, cuando no existen lineamientos claros, los scripts pueden convertirse en una fuente de deuda técnica, riesgos de seguridad y confusión operativa.

Desde una perspectiva organizacional, un script es código productivo, aunque no forme parte directa de la aplicación principal.

## Qué entendemos por “scripts”

En este contexto, un script es cualquier archivo utilizado para:

- Automatizar tareas locales o de CI/CD
- Preparar entornos
- Ejecutar migraciones
- Validar configuraciones
- Ejecutar procesos repetitivos
- Soportar despliegues o releases

Ejemplos comunes:

- Bash (.sh)
- PowerShell (.ps1)
- Python
- Node.js
- Scripts de infraestructura
- Scripts auxiliares de build o test


## El problema de los scripts sin lineamientos

Cuando los scripts se agregan sin reglas claras, suelen aparecer estos problemas:

- Scripts duplicados o inconsistentes
- Dependencia de rutas locales o variables no documentadas
- Scripts que solo funcionan “en la máquina de alguien”
- Lógica crítica fuera del pipeline
- Riesgos de seguridad (credenciales hardcodeadas)
- Falta de versionado o ownership

Por eso, agregar un script debe ser una decisión consciente, no un parche rápido.

## Dónde deben vivir los scripts

Un principio clave es que los scripts deben ser descubribles y predecibles. 

Una estructura común y recomendada:

```text
/scripts
  /ci
  /db
  /infra
  /local
  /maintenance
```

Tambien en algunas ocaciones puede ser conveniente y adecuado dejarlos en `/src` pero esto solo si es que la cantidad de scripts es extremadamente pequeña o es un unico script para una tarea en específico.
 
## Un script es parte del producto

Un error frecuente es tratar los scripts como “helpers” sin importancia. En realidad:

- Afectan cómo se construye
- Afectan cómo se despliega
- Afectan cómo se mantiene el sistema

Por lo tanto:

- Deben versionarse
- Deben revisarse
- Deben documentarse
- Deben probarse cuando sea posible

Si un script rompe el pipeline, rompe el producto.

### Ejemplo: script mal agregado

```bash
#!/bin/bash
export DB_PASSWORD=123456
dotnet ef database update
```

Problemas:

- Credenciales hardcodeadas
- Sin validaciones
- Sin contexto
- Sin documentación
- Alto riesgo de filtración

Este tipo de scripts suele terminar detectado por herramientas de seguridad o, peor, en producción.

### Ejemplo: script agregado correctamente

```bash
#!/bin/bash
set -e

if [ -z "$DB_CONNECTION_STRING" ]; then
  echo "DB_CONNECTION_STRING is not set"
  exit 1
fi

dotnet ef database update
```

Mejoras claras:

- No hay secretos en el código
- Valida precondiciones
- Falla de forma explícita
- Es portable a CI/CD


## Documentación mínima requerida

Todo script agregado debe incluir:

- Qué hace
- Cuándo se usa
- Qué variables requiere
- Qué impacto tiene
- Si es seguro ejecutarlo en producción o no

Ejemplo simple en el header:

```bash
# Purpose: Run database migrations
# Required env vars: DB_CONNECTION_STRING
# Safe for production: Yes
```

## Buenas prácticas

- Mantener scripts en carpetas dedicadas
- Usar nombres claros y consistentes
- Evitar lógica compleja innecesaria
- Preferir reutilizar scripts existentes
- Validar variables y dependencias
- Documentar uso y riesgos
- Ejecutarlos desde CI cuando sea posible


## Do’s & Don’ts
### Do

- Versionar todos los scripts
- Revisarlos en PR
- Validar inputs y variables
- Usar secret managers
- Mantenerlos simples y claros
- Alinear scripts locales con CI/CD

### Don’t

- Hardcodear credenciales
- Agregar scripts sin documentación
- Depender de paths locales
- Ejecutar scripts críticos solo manualmente
- Duplicar scripts con ligeras variaciones
- Omitir revisiones por “ser solo un script”

