# Merging, rebase, squash: Cuando aplicar cada uno

Integrar código no es solo “juntar ramas”.
La estrategia que elijas **define la calidad del historial**, la facilidad de mantenimiento y la capacidad de respuesta ante errores.

No existe una estrategia universal, pero **sí reglas claras de uso**.

## Principio base

> **La forma en que integras código es una decisión de diseño del historial.**

El objetivo no es:

* Minimizar comandos
* Evitar conflictos “como sea”

El objetivo es:

* Historial entendible
* Cambios rastreables
* Capacidad de rollback segura

---

## Merge

### ¿Qué es?

`merge` integra una rama **preservando toda su historia** y creando (normalmente) un *merge commit*.
Esta estrategia es buena porque es una operación no destructiva . Las ramas existentes no se modifican de ninguna manera.

Esto crea una nueva confirmación de fusión en la rama maestra que une los historiales de ambas ramas, lo que le da una estructura de rama que se ve así:

```
main ────●────●────●
          \        /
           ●────●
            feature
```

---

### Cuándo USAR merge

#### 1. Integración de ramas de larga duración

Ejemplos:

* `main`
* `develop`
* `release/*`

Aquí **preservar la historia importa**.

---

#### 2. Cuando la secuencia de commits tiene valor histórico

Ejemplo:

* Investigación
* Evolución progresiva
* Refactors complejos paso a paso

---

#### 3. Cuando varios desarrolladores trabajaron en la rama

Preservar quién hizo qué y cuándo **es relevante**.

---

### Ejemplo correcto

```bash
Merge branch 'release/1.4.0' into main
```

Este commit:

* Marca un hito
* Es fácil de identificar
* Permite revertir una versión completa

---

### Cuándo NO usar merge

- Para ramas pequeñas con commits ruidosos
- Para features simples
- Cuando el historial queda ilegible

Ejemplo incorrecto:

```bash
Merge branch 'fix-typo'
```

Para esto, `merge commit` agrega ruido innecesario.

---

## Rebase

### ¿Qué es?

`rebase` **reaplica commits** sobre otra base, reescribiendo el historial para hacerlo lineal.
Como alternativa al merge, puedes hacer rebase la rama maestra en la rama de desarrollo usando los siguientes comandos:

```bash
git checkout dev
git rebase main
```

Visualmente:

```
Antes:
main ───●────●
          \
           ●────● feature

Después:
main ───●────●────●────●
```
Esto mueve toda la rama de desarrollo para que comience en el extremo de la masterrama, incorporando efectivamente todas las nuevas confirmaciones en master. Sin embargo, en lugar de usar una confirmación de fusión, la reorganización reescribe el historial del proyecto creando nuevas confirmaciones para cada confirmación en la rama original.

La principal ventaja de rebasar es que se obtiene un historial de proyecto mucho más limpio. En primer lugar, elimina las confirmaciones de fusión innecesarias que requiere git merge. En segundo lugar, como se puede ver en el diagrama anterior, rebasar también resulta en un historial de proyecto perfectamente lineal: se puede seguir la pista de dev hasta el inicio del proyecto sin bifurcaciones. 

---

### Cuándo USAR rebase

#### 1. Para mantener tu rama actualizada

Durante el desarrollo:

```bash
git rebase main
```

Esto:

* Reduce conflictos al final
* Mantiene historia limpia

---

#### 2. Para limpiar commits antes de abrir PR

Ejemplo antes:

```bash
WIP
Fix tests
Fix tests again
Remove debug logs
```

Después de rebase interactivo:

```
Add validation for order cancellation
```

---

#### 3. Para reordenar commits lógicamente

Cuando el orden real de desarrollo no es el orden lógico.

---

### Cuándo NO usar rebase

En ramas compartidas
En ramas ya publicadas
En `main` o `develop`

> Reescribir historia compartida rompe confianza.

---

### Regla del equipo

> **Rebase es una herramienta personal, no colectiva.**

---

## Squash

### ¿Qué es?

`squash` **combina múltiples commits en uno solo**.

No cambia el contenido final,
pero **simplifica drásticamente el historial**.

---

### Cuándo USAR squash

#### 1. Features pequeñas o medianas

Ejemplo:

* Validaciones
* Ajustes de lógica
* Bugs aislados

---

#### 2. Commits temporales o exploratorios

Todo lo que fue:

* Debug
* Pruebas
* Ajustes rápidos

Debe desaparecer del historial final.

---

#### 3. Cuando el valor está en el resultado, no en el proceso

Ejemplo:

```bash
Add retry logic for payment service
```

No importa cómo llegaste ahí, solo que quedó bien.

---

### Ejemplo correcto

Antes:

```bash
WIP
Fix typo
Adjust logic
Now it works
```

Después:

```bash
fix(payment): add retry logic with idempotency check
```

---

### Cuándo NO usar squash

- Cambios complejos con múltiples decisiones
- Refactors grandes
- Ramas con valor histórico

Aquí perderías información valiosa.

---

## Comparación rápida

| Estrategia | Preserva historia | Reescribe historia | Uso principal            |
| ---------- | ----------------- | ------------------ | ------------------------ |
| Merge      | Sí                | No                 | Integración formal       |
| Rebase     | No                | Sí                 | Limpieza / actualización |
| Squash     | Parcial           | Sí                 | Simplificación           |

---

## Estrategia recomendada del equipo

### Flujo sugerido

1. Desarrollo libre en rama personal
2. Rebase frecuente con `main`
3. Limpieza de commits (rebase interactivo)
4. PR con historial claro
5. Merge o Squash según el tipo de cambio


