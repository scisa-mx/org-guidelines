# Reglas para commits, mensajes y atomicidad

## Principios base / generales
Al utilizar git para el control de versiones, es importante seguir ciertas reglas y convenciones para asegurar que los commits sean claros, útiles y fáciles de entender para todos los miembros del equipo. Estas reglas pueden integrarse como:

- El repositorio es un medio de comunicación entre los desarrolladores.
- Atomicidad 
- El historial debe de contar una historia coherente.
- Git es una herramienta de equipo, no personal.


## El repositorio es un medio de comunicación entre los desarrolladores

Git no solo se trata de guardar cambios de código en el proyecto, al fin y al cabo este historial y repositorio termina abarcando muchas personas, equipos y a lo largo del tiempo. Por ello, es importante que los commits sean claros y descriptivos, de modo que cualquier persona pueda entender qué cambios se han realizado y por qué.

El historial es una conversación técnica asincrónica entre:

- Quien escribió el código
- Quien lo revisó
- Quien lo mantendrá en el futuro
- Tu “yo” de hace 6 meses

Por lo que tienes que:

- Procurar la claridad del código y los commits para el tu del futuro.
- Escribir mensajes de commit descriptivos y significativos, para que otros desarrolladores puedan entender fácilmente los cambios realizados.

Cada commit es un mensaje dirigido a otras personas. ¿Qué implica este principio?

- El historial se lee, no solo se ejecuta
- Los commits deben poder entenderse sin contexto externo
- Un buen historial reduce preguntas, errores y suposiciones

*** Ejemplo negativo: ***

```bash
commit 1a2b3c
"cambios"
```

Este commit no comunica nada:
- ¿Qué cambió?
- ¿Por qué?
- ¿Es seguro revertirlo?

*** Ejemplo con mejores prácticas: ***

```bash
commit 1a2b3c
fix: corregir error de validación en formulario de registro de usuarios cuando un usuario esta inactivo
```

Aquí el commit:

- Explica el problema
- Da contexto
- Ayuda a quien depura un bug relacionado

> Principio cultural
> Si alguien tiene que abrir el diff para entender qué hiciste, el mensaje falló.


## Atomicidad

Un commit atómico:

- Compila
- Pasa tests
- No deja el sistema en estado inconsistente

Es importante que cada commit no rompa directamente la funcionalidad del proyecto. Si un commit introduce errores o problemas, puede dificultar la colaboración y el mantenimiento del código, es posible que otros desarrolladores no puedan trabajar con el código hasta que se solucionen los problemas.

Aunque es posible que se metan esta clase de errores de forma accidental, es importante esforzarse por evitarlo.

### No mezclar responsabilidades entre los commits

#### Incorrecto:
Fix + refactor
Feature + formato
Lógica + renaming

#### Correcto:
Commit 1: refactor
Commit 2: cambio funcional

## Commits y PRs
Relación correcta entre commits y Pull Requests

Una confusión común es pensar que el PR reemplaza a los commits.
En realidad, cumplen roles distintos y complementarios:

Los commits cuentan el cómo
Explican qué pasos técnicos se dieron para llegar a una solución.

El Pull Request explica el por qué
Da el contexto: decisiones, alternativas descartadas, impacto y alcance.

Dicho de otra forma:

Si el PR desaparece, el historial de commits debe seguir siendo entendible.
Si los commits desaparecen, el PR no debería existir.

## Commits: el detalle técnico

Los commits deben responder preguntas como:

¿Qué se cambió exactamente?

¿En qué orden lógico?

¿Qué parte del sistema se vio afectada?

Ejemplo correcto de secuencia de commits:

```
Add OrderStatus enum
Update Order entity to use OrderStatus
Adjust OrderRepository queries
Add unit tests for Order status transitions
```

Aquí puedes:

- Revisar cada cambio por separado
- Detectar errores temprano
- Revertir solo una parte si algo falla

Ejemplo incorrecto:
```
Fix order stuff
```

Este commit:

- No comunica intención
- Mezcla cambios
- Hace peligrosa la reversión

## Formatos de mensajes de commit

Los mensajes de commit no son un formalismo:
son una interfaz pública del historial del proyecto.

Un buen mensaje de commit permite:

- Entender qué cambió sin abrir el diff
- Saber por qué se hizo el cambio
- Navegar el historial con confianza
- Automatizar procesos (changelogs, versionado, CI/CD)
- Un mal mensaje convierte Git en un “dump” de cambios.

### Principios base 
Un mensaje de commit debe explicar la intención del cambio, no narrar lo que hiciste.

***Incorrecto:***

```
added validation
``` 

***Mejores practicas:***
```
fix(order): prevent checkout when order has no items
```

El segundo responde:
- Qué parte del sistema
- Qué problema evita
- Qué comportamiento cambia

### Formato estándar (Recomendado por el autor)
Este es el formato base del equipo, inspirado en `Conventional Commits` y probado para escalar bien.

***Formato:***
```
<tipo>(<scope>): <mensaje corto>
```

En donde: 
- `<tipo>`: la categoría del cambio (feat, fix, docs, style, refactor, test, chore)
- `<scope>`: la parte del sistema afectada (opcional)
- `<mensaje corto>`: una descripción concisa del cambio


### Formato extendido
Este est el formato extendido para mensajes de commit, que incluye una descripción más detallada del cambio realizado.

***Formato:***
```
<tipo>(<scope>): <mensaje corto>

<descripción detallada>
```

***Ejemplo con cuerpo extendido***

```
refactor(auth): extract token validation logic

Token validation logic was duplicated across
multiple controllers. This change centralizes
the logic to reduce inconsistency and improve testability.
```

### Tipos estándar permitidos
La tabla se mantiene como estándar del equipo

| Tipo     | Uso                                       |
| -------- | ----------------------------------------- |
| feat/add | Nueva funcionalidad                       |
| fix      | Corrección de bug                         |
| refactor | Cambio interno sin alterar comportamiento |
| test     | Tests nuevos o ajustados                  |
| docs     | Documentación                             |
| chore    | Tareas técnicas sin impacto funcional     |
| bump     | Actualización de dependencias y/o versión |

### Formato orientado a corrección crítica

Útil para:

- Bugs en producción
- Hotfixes
- Incidentes

***Formato:***
```
fix(<scope>): <síntoma>

Root cause:
<causa real>

Fix:
<qué se hizo>
```

***Ejemplo:***
```
fix(payment): duplicate charge on retry

Root cause:
Retry logic did not check idempotency key.

Fix:
Added idempotency validation before processing payment.
```