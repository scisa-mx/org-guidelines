# Inmutabilidad de clases

En sistemas con complejidad alta, la mayoría de los bugs no vienen de algoritmos complejos, sino de estado mutable compartido, efectos colaterales y objetos que cambian “por detrás”.
La inmutabilidad es una de las herramientas más efectivas para combatir este problema.

---

## 1. ¿Qué es la inmutabilidad?
Un objeto inmutable es aquel cuyo estado no puede cambiar después de ser creado.

En .NET, esto NO significa:

- Solo usar private set
- Usar readonly “porque sí”
- Evitar setters públicos pero mutar listas internas

### Ejemplo de falsa inmutabilidad

```csharp
public class Order
{
    public List<OrderItem> Items { get; private set; }
}
```
Aunque Items no tenga setter público, el estado sigue siendo mutable.

### Ejemplo de verdadera inmutabilidad

```csharp
public sealed class Order
{
    public IReadOnlyList<OrderItem> Items { get; }

    public Order(IReadOnlyList<OrderItem> items)
    {
        Items = items;
    }
}
```

IReadOnlyList representa una colección de solo lectura de elementos a los que puede acceder el índice, en el caso de querer o intentar modificar la colección, se lanzará una excepción en tiempo de compilación.


## ¿Por qué inmutabilidad? (beneficios reales)

1. **Menos bugs**
    - No hay cambios inesperados de estado
    - No hay dependencias ocultas entre métodos

2. **Código más predecible**
    - Un objeto siempre representa lo mismo
    - El flujo mental del código es más simple

3. **Thread-safety**
    - Ideal para APIs, workers, background services

4. **Mejor testabilidad**
    - Tests más simples y confiables
    - Menos mocks

## Inmutabilidad y SRP (Single Responsibility Principle)
Si no conoces que es SRP te recomiendo leer primero la guía sobre [SOLID](../04.2.SOLID.md).

### Problemas de objetos mutables
Un objeto mutable suele terminar teniendo más de una responsabilidad:

#### El problema de la "Gestión del Ciclo de Vida"
En un objeto mutable, la clase no solo se encarga de su lógica de negocio, sino también de gestionar el tiempo. Debe asegurar que, si el estado cambia del punto A al punto B, ese cambio sea válido en cualquier momento de la ejecución.

- **Responsabilidad extra**: El objeto debe actuar como una "máquina de estados".

- **Consecuencia**: El código se llena de condicionales `(if (estado == X) ...)` para evitar que el objeto quede en un estado inconsistente.

#### Es necesario validar cambios de estado
Un objeto inmutable no "cambia"; simplemente es. Esto libera a la clase de la responsabilidad de vigilar qué sucede después de su creación.

### Beneficios de objetos inmutables

#### Reducción de la Carga Cognitiva
El objeto es una "fotografía". Su validez está garantizada desde el constructor. La única responsabilidad de la clase es representar un dato o concepto, no vigilar su evolución.

#### Patrones de diseño más simples
El patrón "Value Object" menciona que la inmutabilidad permite que las clases se comporten como Valores (como el número 5 o el color Rojo) y no como Entidades.

#### No orquesta procesos
Un objeto inmutable no necesita orquestar procesos para mantener su validez. Esto reduce la complejidad y mejora la mantenibilidad del código.

## Inmutabilidad como defensa contra efectos colaterales
Los efectos colaterales son el enemigo silencioso del código con alta complejidad.


```csharp
order.ApplyDiscount(10);
```
*¿Qué más cambió? ¿Totales? ¿Impuestos? ¿Auditoría?*

Con inmutabilidad:

```csharp
var discountedOrder = order.ApplyDiscount(10);
```
Ahora:

- El método es explícito
- El cambio es visible
- El flujo es rastreable

Una buena práctica es:
Si una operación cambia algo relevante, debe devolver un nuevo objeto.

## DTOs inmutables

### ¿Qué es realmente un DTO?
Un Data Transfer Object:

- Representa un contrato
- Transporta datos entre capas o sistemas
- No contiene lógica de negocio
- No debería cambiar una vez creado

Si un DTO cambia en el camino:

- El contrato se vuelve implícito
- El flujo es difícil de rastrear
- Aparecen efectos colaterales

### El problema de los DTOs mutables

Imaginemos el siguiente ejemplo: 

```csharp
public class UserDto
{
    public string Name { get; set; }
    public string Email { get; set; }
}
```
Tenemos un DTO mutable para un User, que puede cambiar en cualquier capa del sistema o dentro de nuestra API.
Si en algún punto llega a modificarse, por ejemplo, el Email:

```csharp
userDto.Email = null; // ¿quién lo hizo? ¿por qué?
```
Esto puede causar errores difíciles de rastrear. Nos enfrentamos a problemas como:
- Validaciones que fallan inesperadamente
- Datos inconsistentes

Un DTO mutable no es un contrato, es simplemente una sugerencia.

## DOs / DON’Ts

### DOs
- Separar DTOs de entrada y salida
- Mantener DTOs simples y planos
- Usar `init` cuando sea necesario

### DON’Ts
- Reutilizar DTOs como entidades
- Exponer setters públicos
- Modificar DTOs en runtime

